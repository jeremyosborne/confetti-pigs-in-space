<!DOCTYPE html>
<html>
    <head>
        <title>Anti-aircraft Flak</title>
        <link href="css/grayscale.css" rel="stylesheet"/>
        <script src="lib/jsgamesoup.js"></script>
        <script>
// Nomenclature and style
// g -> if used, refers to a local reference to the JSGameSoup class.
// c -> if used, refers to a local reference to the Canvas drawing context.
window.onload = function() {
    // Early warning if in an old browser that doesn't support 
    // document.querySelector.
    if (!document.querySelector) {
        alert("This example needs a newer browser that supports document.querySelector.");
    }
    
    
    
    // The "world" provides the background, as well as the tracking area
    // for the mouse.
    var World = function() {
        var canvas = document.querySelector("#game");
        this.width = canvas.width;
        this.height = canvas.height;
    };
    // Every frame the world is responsible for clearing the canvas of
    // any previous drawings.
    World.prototype.draw = function(c, g) {
        g.clear();
        g.background('rgba(100, 100, 100, 1.0)');
    };
    // To detect mouseclicks in the world, define the bounding box of the
    // world and listen to the click event.
    World.prototype.pointerBox = function() {
        return [0, 0, this.width, this.height];
    };
    World.prototype.pointerDown = function() {
        // Add a new flak explosion everytime we mouse down.
        // The Flak object will manage its own animation, and eventual
        // removal from the map.
        game.addEntity(new Flak(game.pointerPosition[0], game.pointerPosition[1]));
    };
    
    
    
    // Animates an explosion on the game field.
    var Flak = function(x, y) {
        // The center point of the flak explosion.
        this.x = x;
        this.y = y;
    };
    // The current (and initial) radius in pixels of the explosion.
    Flak.prototype.radius = 1;
    // The maximum radius in pixels of the explosion.
    Flak.prototype.maxRadius = 25;
    // Are we expanding or contracting?
    Flak.prototype.expanding = true;
    // Every frame, increase, or decrease, the size of the flak radius.
    Flak.prototype.update = function(g) {
        if (this.expanding) {
            this.radius += 1;
            if (this.radius >= this.maxRadius) {
                this.expanding = false;
            }
        }
        else {
            // Expanding, and might disappear.
            this.radius -= 1;
            if (this.radius < 1) {
                // Remove the spent flak
                g.delEntity(this);
            }
        }
    };
    // Draw our flak circle.
    Flak.prototype.draw = function(c, g) {
        // Modify the color based on radius.
        var green = 5 * this.radius;
        green = green < 255 ? green : 255;
        
        c.fillStyle = "rgba(255, "+ green+", 0, 0.7)";
        // Use default canvas drawing methods.
        c.beginPath();
        c.arc(this.x, this.y, this.radius, 0, Math.PI*2, true);
        c.fill();
    };
    
    
    
    // Our mouse tracker is not shown as part of the canvas, but we take
    // advantage of the update method to update our mouse coords.
    var MouseCoords = function() {
        this.domX = document.querySelector("#pointer-coords .x");
        this.domY = document.querySelector("#pointer-coords .y");
    };
    // The update method "draws" the coordinates into the DOM.
    MouseCoords.prototype.update = function() {
        // Last mouse position within the game field.
        var pos = game.pointerPosition;
        this.domX.innerHTML = pos[0];
        this.domY.innerHTML = pos[1];
    };
    
    
    
    // Use a crosshair to track the mouse around the game.
    var Crosshair = function() {
        // Only when we mouse over show the crosshair.
        // Coordinates are always relative to the canvas.
        this.x = undefined;
        this.y = undefined;
        // Radial distance of each hand of the crosshair (in pixels).
        this.radius = 10;
    };
    // Called every frame to grab the coordinates of the cross hair.
    Crosshair.prototype.update = function() {
        // Last mouse position within the game field.
        var pos = game.pointerPosition;
        this.x = pos[0];
        this.y = pos[1];
    };
    // Called every frame to redraw the crosshair on the game field.
    Crosshair.prototype.draw = function(c) {
        var x = this.x,
            y = this.y,
            radius = this.radius;
        // Use canvas methods directly to draw.
        c.strokeStyle = 'rgba(255, 255, 255, 1.0)';
        
        c.beginPath();
        // Vertical line.
        c.moveTo(x, y-radius);
        c.lineTo(x, y+radius);
        // Horizontal line.
        c.moveTo(x-radius, y);
        c.lineTo(x+radius, y);
        c.stroke();
    };



    // Initialize the game objects and run the game.
    var game = new JSGameSoup(document.querySelector("#game"), 40);
    // We will need the dimensions provided by world.
    var world = new World();
    game.addEntity(world);
    game.addEntity(new MouseCoords());
    game.addEntity(new Crosshair());
    game.launch();
};
        </script>
    </head>
    <body>
        <canvas id='game' width="600" height="600"></canvas>
        <div id="pointer-coords">
            X: <span class="x"></span>
            Y: <span class="y"></span>
            (coordinates of mouse relative to the game field canvas)
        </div>
    </body>
</html>
